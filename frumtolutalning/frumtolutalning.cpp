#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;

using namespace std;
typedef long long ll;
#define int ll
typedef vector<int> vi;
typedef vector<vector<int>> vvi;
typedef vector<string> vs;
typedef vector<double> vd;
typedef vector<vd> vvd;
typedef vector<char> vc;
typedef unsigned long long ull;
typedef pair<int, int> pii;
typedef pair<double, double> pdd;
typedef vector<pair<int, int>> vpii;
typedef vector<pair<double, double>> vpdd;
typedef tuple<int, int, int> iii;

#define pb push_back
#define em emplace
#define mp make_pair
#define all(x) x.begin(), x.end()
#define rep(i, a, b) for (int i = a; i < b; i++)
#define INF 1e9
#define LLINF 4e18
#define umap unordered_map
#define uset unordered_set

namespace pcf
{
// initialize once by calling init()
#define MAXN 20000010      // initial sieve limit
#define MAX_PRIMES 2000010 // max size of the prime array for sieve
#define PHI_N 100000
#define PHI_K 100

    int len = 0; // total number of primes generated by sieve
    int primes[MAX_PRIMES];
    int pref[MAXN];       // pref[i] --> number of primes <= i
    int dp[PHI_N][PHI_K]; // precal of yo(n,k)
    bitset<MAXN> f;
    void sieve(int n)
    {
        f[1] = true;
        for (int i = 4; i <= n; i += 2)
            f[i] = true;
        for (int i = 3; i * i <= n; i += 2)
        {
            if (!f[i])
            {
                for (int j = i * i; j <= n; j += i << 1)
                    f[j] = 1;
            }
        }
        for (int i = 1; i <= n; i++)
        {
            if (!f[i])
                primes[len++] = i;
            pref[i] = len;
        }
    }
    void init()
    {
        sieve(MAXN - 1);
        // precalculation of phi upto size (PHI_N,PHI_K)
        for (int n = 0; n < PHI_N; n++)
            dp[n][0] = n;
        for (int k = 1; k < PHI_K; k++)
        {
            for (int n = 0; n < PHI_N; n++)
            {
                dp[n][k] = dp[n][k - 1] - dp[n / primes[k - 1]][k - 1];
            }
        }
    }
    // returns the number of integers less or equal n which are
    // not divisible by any of the first k primes
    // recurrence --> yo(n, k) = yo(n, k-1) - yo(n / p_k , k-1)
    // for sum of primes yo(n, k) = yo(n, k-1) - p_k * yo(n / p_k , k-1)
    int yo(int n, int k)
    {
        if (n < PHI_N && k < PHI_K)
            return dp[n][k];
        if (k == 1)
            return ((++n) >> 1);
        if (primes[k - 1] >= n)
            return 1;
        return yo(n, k - 1) - yo(n / primes[k - 1], k - 1);
    }
    // complexity: n^(2/3).(log n^(1/3))
    int Legendre(int n)
    {
        if (n < MAXN)
            return pref[n];
        int lim = sqrt(n) + 1;
        int k = upper_bound(primes, primes + len, lim) - primes;
        return yo(n, k) + (k - 1);
    }
    // runs under 0.2s for n = 1e12
    int Lehmer(int n)
    {
        if (n < MAXN)
            return pref[n];
        int w, res = 0;
        int b = sqrt(n), c = Lehmer(cbrt(n)), a = Lehmer(sqrt(b));
        b = Lehmer(b);
        res = yo(n, a) + ((1LL * (b + a - 2) * (b - a + 1)) >> 1);
        for (int i = a; i < b; i++)
        {
            w = n / primes[i];
            int lim = Lehmer(sqrt(w));
            res -= Lehmer(w);
            if (i <= c)
            {
                for (int j = i; j < lim; j++)
                {
                    res += j;
                    res -= Lehmer(w / primes[j]);
                }
            }
        }
        return res;
    }
}

int modmul(int a, int b, int M)
{
    int ret = a * b - M * int(1.L / M * a * b);
    return ret + M * (ret < 0) - M * (ret >= M);
}
int modpow(int b, int e, int mod)
{
    int ans = 1;
    for (; e; b = modmul(b, b, mod), e /= 2)
        if (e & 1)
            ans = modmul(ans, b, mod);
    return ans;
}

bool isPrime(int n)
{
    if (n < 2 || n % 6 % 4 != 1)
        return (n | 1) == 3;
    int A[] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022},
        s = __builtin_ctzll(n - 1), d = n >> s;
    for (int a : A)
    { // ^ count trailing zeroes
        int p = modpow(a % n, d, n), i = s;
        while (p != 1 && p != n - 1 && a % n && i--)
            p = modmul(p, p, n);
        if (p != n - 1 && i != s)
            return 0;
    }
    return 1;
}
signed main()
{
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    pcf::init();
    int n, m;
    cin >> n >> m;
    if (m - n <= 1e7)
    {
        int ans = 0;
        for (int i = n; i <= m; i++)
        {
            ans += (isPrime(i) ? 1 : 0);
        }
        cout << ans << endl;
    }
    else
        cout << pcf::Lehmer(m) - pcf::Lehmer(n - 1) << '\n';
    return 0;
}